import { App, TFile, TFolder } from 'obsidian';
import { FolderProfile, FolderNoteContent, PluginSettings } from '../models/types';
import { SmartConnectionsService } from './SmartConnectionsService';

export class VaultScanner {
  private smartConnectionsService: SmartConnectionsService;

  constructor(private app: App, private settings: PluginSettings) {
    // Injecting Smart Connections service for future use
    this.smartConnectionsService = new SmartConnectionsService(app);
  }

  async scanVault(): Promise<FolderProfile[]> {
    const profiles: FolderProfile[] = [];
    const rootFolder = this.app.vault.getRoot();

    await this.scanFolderRecursive(rootFolder, profiles);

    return profiles;
  }

  private async scanFolderRecursive(folder: TFolder, profiles: FolderProfile[]) {
    // Check if folder should be excluded
    if (this.shouldExcludeFolder(folder.path)) {
      return;
    }

    // Get all markdown files in this folder (non-recursive)
    const files = folder.children
      .filter((file): file is TFile => file instanceof TFile && file.extension === 'md')
      .map(f => f);

    // Try to find folder note
    let folderNote: FolderNoteContent | null = null;
    for (const indexName of this.settings.indexFileNames) {
      const indexFile = folder.children.find(f =>
        f instanceof TFile && f.name === indexName
      );
      if (indexFile && indexFile instanceof TFile) {
        folderNote = await this.extractFolderNote(indexFile);
        break;
      }
    }

    // Create folder profile
    let coherenceScore = 0.7;
    let folderCentroid: number[] | undefined = undefined;
    let hasValidCentroid = false;

    // Add this at the START of the centroid calculation section
    console.log(`[CENTROID] Calculating centroid for folder: ${folder.path}`);
    console.log(`[CENTROID] Folder has ${files.length} notes`);

    if (this.settings.useSmartConnectionsIfAvailable && this.smartConnectionsService.isSmartConnectionsAvailable()) {
         coherenceScore = await this.smartConnectionsService.calculateCoherence(files);

         // Calculate folder centroid (average embedding)
         console.log(`[CENTROID] Smart Connections available, calculating centroid...`);
         try {
             // @ts-ignore
             const centroid = await this.smartConnectionsService.calculateFolderCentroid(folder, files);
             if (centroid) {
                 folderCentroid = centroid;
                 hasValidCentroid = true;
                 console.log(`[CENTROID] ✓ Centroid calculated for ${folder.path}`);
             } else {
                 console.log(`[CENTROID] ✗ No valid centroid for ${folder.path}`);
             }
         } catch (error) {
             console.error('Error calculating centroid for ' + folder.path + ':', error);
         }
    } else {
        console.log(`[CENTROID] Smart Connections not available or disabled`);
    }

    const profile: FolderProfile = {
      folderPath: folder.path,
      folderName: folder.name,
      fileCount: files.length,
      avgNoteAge: this.calculateAvgAge(files),
      themeKeywords: folderNote?.keyTopics || [],
      description: folderNote?.description || this.generateDescription(folder, files),
      folderNote,
      coherenceScore: coherenceScore,
      folderCentroid: folderCentroid,
      hasValidCentroid: hasValidCentroid,
      examples: files.slice(0, 3).map(f => f.basename)
    };

    profiles.push(profile);

    // Recursively scan subfolders
    for (const child of folder.children) {
      if (child instanceof TFolder) {
        await this.scanFolderRecursive(child, profiles);
      }
    }
  }

  private async extractFolderNote(file: TFile): Promise<FolderNoteContent> {
    const content = await this.app.vault.read(file);

    // Simple extraction: read first few lines as description
    const lines = content.split('\n').slice(0, 10);
    const description = lines.filter(l => !l.startsWith('#')).join(' ').trim();

    return {
      path: file.path,
      title: file.basename,
      description: description || 'No description',
      keyTopics: [],
      relatedFolders: [],
      isAutoGenerated: false
    };
  }

  private generateDescription(folder: TFolder, files: TFile[]): string {
    // Generate description from folder name and file names
    const folderNameSuggestion = folder.name
      .replace(/[_-]/g, ' ')
      .replace(/([A-Z])/g, ' $1')
      .trim();

    if (files.length === 0) {
      return `${folderNameSuggestion} (empty)`;
    }

    return `${folderNameSuggestion}. Contains ${files.length} notes.`;
  }

  private calculateAvgAge(files: TFile[]): number {
    if (files.length === 0) return 0;

    const now = Date.now();
    const ages = files.map(f => (now - f.stat.ctime) / (1000 * 60 * 60 * 24)); // days

    return ages.reduce((a, b) => a + b, 0) / ages.length;
  }


  private shouldExcludeFolder(path: string): boolean {
    return this.settings.excludedFolders.some(pattern => {
      try {
        const regex = new RegExp(pattern);
        return regex.test(path);
      } catch {
        return path.includes(pattern);
      }
    });
  }

  getAllFolders(): { name: string; path: string; level: number }[] {
    const folders: { name: string; path: string; level: number }[] = [];
    const root = this.app.vault.getRoot();

    const walk = (folder: TFolder) => {
      for (const child of folder.children) {
        if (child instanceof TFolder) {
           if (this.shouldExcludeFolder(child.path)) continue;

           folders.push({
             name: child.name,
             path: child.path,
             level: child.path.split('/').length - 1
           });
           walk(child);
        }
      }
    };

    walk(root);
    return folders.sort((a, b) => a.path.localeCompare(b.path));
  }
}
