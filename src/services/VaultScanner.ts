import { App, TFile, TFolder } from 'obsidian';
import { FolderProfile, FolderNoteContent, PluginSettings } from '../models/types';
import { SmartConnectionsService } from './SmartConnectionsService';

export class VaultScanner {
  private smartConnectionsService: SmartConnectionsService;

  constructor(private app: App, private settings: PluginSettings) {
    // Injecting Smart Connections service for future use
    this.smartConnectionsService = new SmartConnectionsService(app);
  }

  async scanVault(): Promise<FolderProfile[]> {
    const profiles: FolderProfile[] = [];
    const rootFolder = this.app.vault.getRoot();

    await this.scanFolderRecursive(rootFolder, profiles);

    return profiles;
  }

  private async scanFolderRecursive(folder: TFolder, profiles: FolderProfile[]) {
    // Check if folder should be excluded
    if (this.shouldExcludeFolder(folder.path)) {
      return;
    }

    // Get all markdown files in this folder (non-recursive)
    const files = folder.children
      .filter((file): file is TFile => file instanceof TFile && file.extension === 'md')
      .map(f => f);

    // Try to find folder note
    let folderNote: FolderNoteContent | null = null;
    for (const indexName of this.settings.indexFileNames) {
      const indexFile = folder.children.find(f =>
        f instanceof TFile && f.name === indexName
      );
      if (indexFile && indexFile instanceof TFile) {
        folderNote = await this.extractFolderNote(indexFile);
        break;
      }
    }

    // Create folder profile
    let coherenceScore = 0.7;
    let folderCentroid: number[] | undefined = undefined;
    let hasValidCentroid = false;

    if (this.settings.useSmartConnectionsIfAvailable && this.smartConnectionsService.isAvailable()) {
         coherenceScore = await this.smartConnectionsService.calculateCoherence(files);

         // Calculate folder centroid (average embedding)
        try {
            if (files.length > 0) {
                const embeddings: number[][] = [];
                for (const noteFile of files) {
                    try {
                        const embedding = await this.smartConnectionsService.getNoteEmbedding(noteFile);
                        if (embedding && embedding.length > 0) {
                            embeddings.push(embedding);
                        }
                    } catch (e) {
                         continue;
                    }
                }

                if (embeddings.length > 0 && embeddings[0]) {
                    // Calculate centroid
                    const dim = embeddings[0].length;
                    const centroid = new Array(dim).fill(0);
                    for (let i = 0; i < dim; i++) {
                        for (const emb of embeddings) {
                            centroid[i] += (emb[i] || 0);
                        }
                        centroid[i] /= embeddings.length;
                    }
                    folderCentroid = centroid;
                    hasValidCentroid = true;
                }
            }
         } catch (error) {
             console.error('Error calculating centroid for ' + folder.path + ':', error);
         }
    }

    const profile: FolderProfile = {
      folderPath: folder.path,
      folderName: folder.name,
      fileCount: files.length,
      avgNoteAge: this.calculateAvgAge(files),
      themeKeywords: folderNote?.keyTopics || [],
      description: folderNote?.description || this.generateDescription(folder, files),
      folderNote,
      coherenceScore: coherenceScore,
      folderCentroid: folderCentroid,
      hasValidCentroid: hasValidCentroid,
      examples: files.slice(0, 3).map(f => f.basename)
    };

    profiles.push(profile);

    // Recursively scan subfolders
    for (const child of folder.children) {
      if (child instanceof TFolder) {
        await this.scanFolderRecursive(child, profiles);
      }
    }
  }

  private async extractFolderNote(file: TFile): Promise<FolderNoteContent> {
    const content = await this.app.vault.read(file);

    // Simple extraction: read first few lines as description
    const lines = content.split('\n').slice(0, 10);
    const description = lines.filter(l => !l.startsWith('#')).join(' ').trim();

    return {
      path: file.path,
      title: file.basename,
      description: description || 'No description',
      keyTopics: [],
      relatedFolders: [],
      isAutoGenerated: false
    };
  }

  private generateDescription(folder: TFolder, files: TFile[]): string {
    // Generate description from folder name and file names
    const folderNameSuggestion = folder.name
      .replace(/[_-]/g, ' ')
      .replace(/([A-Z])/g, ' $1')
      .trim();

    if (files.length === 0) {
      return `${folderNameSuggestion} (empty)`;
    }

    return `${folderNameSuggestion}. Contains ${files.length} notes.`;
  }

  private calculateAvgAge(files: TFile[]): number {
    if (files.length === 0) return 0;

    const now = Date.now();
    const ages = files.map(f => (now - f.stat.ctime) / (1000 * 60 * 60 * 24)); // days

    return ages.reduce((a, b) => a + b, 0) / ages.length;
  }


  private shouldExcludeFolder(path: string): boolean {
    return this.settings.excludedFolders.some(pattern => {
      try {
        const regex = new RegExp(pattern);
        return regex.test(path);
      } catch {
        return path.includes(pattern);
      }
    });
  }

  getAllFolders(): { name: string; path: string; level: number }[] {
    const folders: { name: string; path: string; level: number }[] = [];
    const root = this.app.vault.getRoot();

    const walk = (folder: TFolder) => {
      for (const child of folder.children) {
        if (child instanceof TFolder) {
           if (this.shouldExcludeFolder(child.path)) continue;

           folders.push({
             name: child.name,
             path: child.path,
             level: child.path.split('/').length - 1
           });
           walk(child);
        }
      }
    };

    walk(root);
    return folders.sort((a, b) => a.path.localeCompare(b.path));
  }
}
